Correction du controle continu

STRNSPN

// Le caractere c est-il dans accept (pt) ?
int instr(char  c,  char  *pt){   //inline
    while (*pt){
      if (*pt==c) return 1;
      pt++;
       }
       return 0;
}
 
size_t strnspn(char * str,  char  *delim){
    size_t res=0;  
    while (*str ) { // parcours
        int nb=0;   
        // tant que on est pas à la fin de la str
        // et que le caractere est dans delim
        while (*str  && ( instr(*str,delim))) {
        str++; // on avance
        nb++;
        }
        if (nb>res)    res=nb; //max
        if     (*str) str++; //avance
    }  
    return res;  
}
TxtConcat

struct txt_s * txtConcatNB_V1(struct txt_s *   texte,int nb){
   struct txt_s * result= txtCreat(); // creer un nouveau texte
   struct maillon * p = texte->premier;
   char *buf=(char *)malloc(10*4196);
   
   //parcours les maillons
   while (p != (struct maillon *) NULL){
       int n = nb-1;
       strcpy(buf,p->ligne);  // stock la première chaine  
       p = p->suivant;
       // suite de NB maillon
       while ( p != (struct maillon *) NULL && n){
         strcat(buf,p->ligne); // concatenne
         p = p->suivant;
         n--;
       }     
       txtAddStr(result,buf);  // ajoute la ligne dans le nouveau texte     
    }
    free(buf);
    return result;
  }
VERSION avec  les numeros de ligne

struct txt_s * txtConcatNB(struct txt_s *   texte,int nb){
   struct txt_s * result= txtCreat(); // creer un nouveau texte
   struct maillon * p = texte->premier;
   char * totalbuf=(char *)malloc(10*4196); // numeros de ligne plus les chaines
   char *strbuf=(char *)malloc(10*4196); //concat les chaines   
   unsigned li=1;
   //parcours les maillons
   while (p != (struct maillon *) NULL){   
       int n = nb-1;
       unsigned dlig=li;
       strcpy(strbuf,p->ligne);  // stock la première chaine  
       p = p->suivant;
       // suite de NB maillon
       while ( p != (struct maillon *) NULL && n){
         strcat(strbuf,p->ligne); // concatenne la ligne
         p = p->suivant;
         li++;
         n--;
       }
       if (dlig ==li)
         sprintf(totalbuf,"%u %s:",dlig,strbuf); // ou sprintf et strcat
       else
         sprintf(totalbuf,"%u-%u %s:",dlig,li,strbuf);     
       txtAddStr(result,totalbuf);  // ajoute la ligne dans le nouveau texte    
       li++;
    }
    free(strbuf);
    free(totalbuf);
    return result;
  }
TxtCut

truct txt_s * txtCut(struct txt_s *   texte,int nb){
  struct txt_s * result= txtCreat();
  struct maillon * p = texte->premier;
  char *buf=malloc(512);
  while (p != (struct maillon *) NULL){
     
    int nbc=1;
    char *s=p->ligne;
    char *b=buf;
    while( *s && nbc <= nb){       
        *b=*s;
        nbc++;
        s++;
        b++;
    }
    *b='\0';
    txtAddStr(result,buf);
    p = p->suivant;
  }
  return result;
}
