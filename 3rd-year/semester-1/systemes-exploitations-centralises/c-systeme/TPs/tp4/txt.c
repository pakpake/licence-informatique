#include<stdio.h>
#include"txt.h"
#include <stdlib.h> // malloc
#include <string.h>

//  txtCreat
// initialise un objet de type txt_t (struct txt_s * ) 
//
struct txt_s* txtCreat(){
    struct txt_s* res=(struct txt_s*) malloc(sizeof(struct txt_s));
    if (!res) {
        fprintf(stderr,"Erreur création structure dans txtCreat\n");
        exit(EXIT_FAILURE);
    }
    res->premier= (struct maillon * ) NULL; 
    return res;
}


//  txtPrintOut
//  affiche sur la sortie standard
//  les ligned de texte d un objet  txt_t  
//  
void txtPrintOut(struct txt_s* texte){
    struct maillon * p = texte->premier;
    // test cas d'erreur, texte=NULL
    if (texte == NULL) {
        fprintf(stderr,"Erreur txtPrintOut texte vide");
        exit(EXIT_FAILURE);
    }
    while (p != (struct maillon *) NULL){
        // affiche la ligne
        printf("%s\n",p->ligne);
        // deplace sur le maillon suivant
        p = p->suivant;
    }

}

//  txtAddStr
// ajoute une ligne en fin du texte
// dans un objet txt_t  
//
void txtAddStr(struct txt_s* texte, char * l){
    struct maillon * p = NULL;
    struct maillon * t = NULL;

    // test cas d'erreur, texte=NULL
    if (texte == NULL) {
        fprintf(stderr,"Erreur txtPrintOut texte vide");
        exit(EXIT_FAILURE);
    }

    // on créé le nouveau maillon et on vérifie si la création s'est bien passée
    p = (struct maillon *) malloc(sizeof(struct maillon));
    if (!p) {
        fprintf(stderr,"Erreur création maillon dans txtAddStr\n");
        exit(EXIT_FAILURE);
    }

    // on créé la nouvelle dans le maillon et on vérifie si ok
    p -> ligne = malloc(strlen(l)+1);
    if (!p -> ligne) {
        fprintf(stderr,"Erreur création ligne dans txtAddStr\n");
        exit(EXIT_FAILURE);
    }

    // on remplit la ligne du maillon
    strcpy(p -> ligne, l);
    // le suivant est null
    p -> suivant = NULL;

    // on insère le maillon à la fin
    if (texte -> premier != NULL) {
        // cas général
        // on avance jusqu'à la fin de la chaine
        t = texte -> premier;
        while (t -> suivant != NULL) {
            t = t->suivant;
        }
        t -> suivant = p;
    } else {
        // cas particulier
        // la chaine est vide, notre maillon sera seul
        texte -> premier = p;

    }
}

//  txtInsertPos
// insère une ligne et l'ajoute avant la position pos
void txtInsertPos(struct txt_s* texte, int pos, char * l) {
    struct maillon * p = NULL;
    struct maillon * t = NULL;
    int i;  // compteur pour trouver la bonne position

    // test cas d'erreur, texte=NULL
    if (texte == NULL) {
        fprintf(stderr,"Erreur txtPrintOut texte vide");
        exit(EXIT_FAILURE);
    }

    // on créé le nouveau maillon et on vérifie si la création s'est bien passée
    p = (struct maillon *) malloc(sizeof(struct maillon));
    if (!p) {
        fprintf(stderr,"Erreur création maillon dans txtInsertPos\n");
        exit(EXIT_FAILURE);
    }

    // on créé la nouvelle dans le maillon et on vérifie si ok
    p -> ligne = malloc(strlen(l)+1);
    if (!p -> ligne) {
        fprintf(stderr,"Erreur création ligne dans txtInsertPos\n");
        exit(EXIT_FAILURE);
    }

    // on remplit la ligne du maillon
    strcpy(p -> ligne, l);
    // le suivant est null
    p -> suivant = NULL;

    // on insère au début si le texte est vide ou si pos <= 1
    if (texte -> premier == NULL) {
        texte -> premier = p;
    } else if (pos <= 1) {
        p -> suivant = texte -> premier;
        texte -> premier = p;
    } else {
        // on insère le maillon à la bonne position
        t = texte -> premier;
        i = 1;
        // on avance jusqu'à la bonne position où la fin de la liste
        while (t -> suivant != NULL && i < pos-1) {
            t = t->suivant;
            i++;
        }
        // on insère l'élément à sa bonne position
        p -> suivant = t -> suivant;
        t -> suivant = p;
    }
}

void txtSuppPos(struct txt_s* texte, int pos) {
    struct maillon * t = NULL;
    struct maillon * tmp = NULL;
    int i=1;    // compteur de position

    // test cas d'erreur, texte=NULL
    if (texte == NULL) {
        fprintf(stderr,"Erreur txtPrintOut texte vide");
        exit(EXIT_FAILURE);
    }

    // si pos < 1, on ne fait rien
    if (pos >= 1) {
        t = texte -> premier;
        if (pos == 1) {
            // cas particulier on supprime le 1er élément
            tmp = t;    // on sauve l'adresse du maillon à supprimer
            texte -> premier = t -> suivant;    // on raccroche le reste de la liste
            // on libère la mémoire occupée par la ligne du maillon à supprimer
            free(tmp -> ligne); 
            // on libère la mémoire du maillon
            free(tmp);
        } else {
            // cas général on avance jusqu'à la bonne position où la fin de la liste
            while (t -> suivant != NULL && i < pos-1) {
                t = t -> suivant;
                i++;
            }
            tmp = t -> suivant;     // on sauve l'adresse du maillon à supprimer
            if (tmp != NULL) {
                // si on a trouvé l'élément à supprimer
                t -> suivant = t -> suivant -> suivant;     // on raccroche la fin de la liste
                free(tmp -> ligne);
                free(tmp);      
            }
        }
    }
}
