/*
 * ll.c : affiche toute les entrees (fichier ou repertoire)  d'un repertoire
 * utilise les appels systeme opendir,readdir,closedir 
 */

#include <stdio.h>      //librairie standard (stderr)
#include <dirent.h>     // manipulation des repertoire
#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>

/* effectue un ll -l */
int main ( int argc , char **argv ) {
    struct stat file_info;

    DIR * nom_directorie ; // descriteur de repertoire
    struct dirent * fichier ; // structure d'une entree

    char buffer[100];

    time_t timestamp = time(NULL);
    struct tm * pTime = localtime(& timestamp);

    struct passwd *pwd; //= getpwuid(file_info.st_uid);
    struct group  *grp; // = getgrgid(file_info.st_gid);

    int count=0;

    // teste de bonne utilisation
    if ( argc != 2 ) { 
        printf("usage :  %s rep \n",argv[0]);
        exit(1);
    }

    // ourverture du repertoire
    if ( (nom_directorie = opendir(argv[1]))== NULL ){
        perror("ll :");
        exit(errno);
    }

    while ((fichier = readdir(nom_directorie)) != NULL) {
        // appel à stat
        if (stat(fichier->d_name,&file_info) == -1) {
            perror("stat :");
            exit(errno);   
        }
        count+=file_info.st_blocks/2;
    }
    printf("total %d\n",count);

    rewinddir(nom_directorie);
    // lectures des entrees
    // printf("inode  [droit]  uid      taille    date     nom\n");
    while ((fichier = readdir(nom_directorie)) != NULL) {
        // appel à stat
        if (stat(fichier->d_name,&file_info) == -1) {
            perror("stat :");
            exit(errno);   
        }

        pwd = getpwuid(file_info.st_uid);
        grp = getgrgid(file_info.st_gid);

        //printf("%s %s\n",pwd->pw_name, grp->gr_name);

        // pour afficher la date/heure
        timestamp = file_info.st_atime;
        pTime = localtime(&timestamp);
        strftime(buffer, sizeof(buffer), "%b %d %R",pTime);


        switch (file_info.st_mode & S_IFMT) {
            case S_IFBLK:  printf("b"); break;
            case S_IFCHR:  printf("c"); break; 
            case S_IFDIR:  printf("d"); break; //It's a (sub)directory 
            case S_IFIFO:  printf("p"); break; //fifo
            case S_IFLNK:  printf("l"); break; //Sym link
            case S_IFSOCK: printf("s"); break;
                           //Filetype isn't identified
            default:       printf("-"); break;
        }
        //droits
        printf( (file_info.st_mode & S_IRUSR) ? "r" : "-");
        printf( (file_info.st_mode & S_IWUSR) ? "w" : "-");
        printf( (file_info.st_mode & S_IXUSR) ? "x" : "-");
        printf( (file_info.st_mode & S_IRGRP) ? "r" : "-");
        printf( (file_info.st_mode & S_IWGRP) ? "w" : "-");
        printf( (file_info.st_mode & S_IXGRP) ? "x" : "-");
        printf( (file_info.st_mode & S_IROTH) ? "r" : "-");
        printf( (file_info.st_mode & S_IWOTH) ? "w" : "-");
        printf( (file_info.st_mode & S_IXOTH) ? "x" : "-");


        // printf("%ld %s %s %5ld [%3o] %6d %10ld %12s %s\n",
        printf(" %ld %s %s %6ld %12s %s\n",
                file_info.st_nlink,
                pwd->pw_name,
                grp->gr_name,
                // file_info.st_ino,
                // file_info.st_mode & 0777,
                // file_info.st_uid,
                file_info.st_size,
                buffer,
                fichier->d_name);
    }
    closedir(nom_directorie);
}
