#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>

// lit une ligne dans un fd ouvert  (fgets)
char * readLine ( char *adr,size_t size,int fd) {
    int nb= 0;
    char *str = adr;

    // si la taille est inférieur ou égale à 1, on ne fait rien
    if (size > 1) {
        // on lit 1 car que l'on place dans str
        // si le car est bien lu, read renvoie 1
        // on met a jour nb et on vérifie qu'on ne déborde pas de la taille du buffer
        // on regarde si le car lu n'est pas un \n
        while ((read(fd,str,1)==1) && (++nb < size -2) && (*str !='\n'))  
            // on avance dans la chaine de car
            str++; 
        *++str='\0'; // ajoute le  \0 à la fin de la chaine 
    }

    // si le nb est différent de 0, on renvoie la chaine, sinon on renvoie NULL
    return nb ? adr : NULL ;
}

int main(int argc, char * argv[]) {
    int file=0;     // descripteur de fichier par défaut l'entrée standard
    int S_MAX=1024;   // taille du buffer
    int deb = 0; // indice de début
    int fin = 0; // indice de fin
    int i,j ; // indices de boucle
    char * strin = (char *) malloc(S_MAX*sizeof(char *));    // ligne entree
    char * strout = (char *) malloc(S_MAX*sizeof(char *));   // ligne sortie

    // on teste si la création de la ligne s'est bien passée
    if (!strin || !strout) {
        fprintf(stderr,"Erreur allocation mémoire strings");
        exit(EXIT_FAILURE);
    }

    // si on a plus de 4 arguments, erreur
    if (argc != 3 && argc != 4) {
        fprintf(stderr,"usage : cut colDep colFin [fichier]\n");
        exit(EXIT_FAILURE);
    }

    // si on 4 arg exactement, on ouvre le fichier d'entree
    if ((argc == 4) && (file = open(argv[3],O_RDONLY)) == -1 ){
        // message d'erreur problème d'ouverture du fichier
        fprintf(stderr,"coupe : error open read only"); 
        exit(EXIT_FAILURE);
    }

    // on récupère les paramètres
    deb=atoi(argv[1]);
    fin=atoi(argv[2]);
    

    // le fichier d'entree est ouvert, ou c'est l'entree standard
    // on lit une ligne jusqu'à la fin de fichier
    while (readLine(strin,S_MAX,file) != NULL) {
        // on vérifie que les indices sont bons
        if (fin >= deb && fin <= S_MAX) {
            // on recopie la bonne portion de la ligne
            for (i=deb,j=0;i<=fin; i++,j++) strout[j] = strin[i];
            // on affiche le résultat
            printf("%s\n",strout);
        }
    }
}
